package vertxlti

import io.vertx.core.http.{HttpMethod, HttpServerRequest}

import scala.concurrent.{ExecutionContext, Future, Promise}
import com.wbillingsley.handy._
import com.wbillingsley.handy.refOps
import io.vertx.ext.web.RoutingContext

import scala.collection.mutable
import scala.util.Random

extension (req:HttpServerRequest) {
  def refParam(name:String):RefOpt[String] =
    Option.apply(req.getParam(name)).toRefOpt
}

extension[T] (vertxFut:io.vertx.core.Future[T])(using ec:ExecutionContext) {

  def toScala:Future[T] = {
    val p = Promise[T]
    vertxFut.onSuccess { x => p.success(x) }
    vertxFut.onFailure { x => p.failure(x) }
    p.future
  }

  def toRef:RefFuture[T] = {
    toScala.toRef(using ec)
  }

}


class LTIAdvantageHandler(server:Server) {
  
  case class PlatformDetails(token:String, openIdConfig: PlatformOpenIdConfigRegElements)
  
  /** Holds details about a platform we are registering with between requests */
  private val platformTokens = mutable.Map.empty[String, PlatformDetails]

  /**
   * Retrieves the details of an OpenID provider. Used in LTI Advantage 1.3 registration.
   * @param configUrl
   * @return
   */
  def getProviderOpenIdDetails(configUrl:String):Ref[PlatformOpenIdConfigRegElements] = {
    given ec:ExecutionContext = ExecutionContext.global
    
    for {
      req <- server.client.request(HttpMethod.GET, configUrl).toRef
      resp <- req.send().toRef
      json <- resp.body().toRef.map(_.toJsonObject())
    } yield {
      PlatformOpenIdConfigRegElements(
        issuer = json.getString("issuer"),
        tokenEndPoint = json.getString("token_endpoint"),
        tokenEndPointAuthMethodsSupported = Seq.empty, // TODO: add platform details
        tokenEndPointAuthSigningAlgValuesSupp = Seq.empty,  // TODO: add platform details
        jwksUri = Option(json.getString("jwks_uri")),
        authorizationEndPoint = Option(json.getString("authorization_endpoint")),
        registrationEndPoint = Option(json.getString("registration_endpoint")),
        scopesSupported = Seq.empty,  // TODO: add platform details
      )
    }
  }



  def ltiAdvantageConfirmationText(tokenRef:String):String =
    s"""<html>
       |
       |  <h1>Initiate tool registration via LTI Advantage</h1>
       |  
       |  <p>
       |  A registration authorisation token (valid for one hour) has been received from your LMS.
       |  </p>
       |  
       |  <p>
       |  Clicking "Confirm" will cause this tool to send a registration request to your
       |  LMS, to configure LTI 1.3 integration. This gives your LMS the URLs it needs in order
       |  to launch activities in this tool.
       |  </p>
       |  
       |  <p>
       |  If Moodle is your LMS, the tool integration will be in a "pending" state, awaiting
       |  a Moodle administrator to set it to active.
       |  </p>
       |  
       |  <p>
       |  If you do not wish to configure the tool in your LMS, simply close this dialog.
       |  The LMS's authorisation token will expire in one hour.
       |  </p>
       |  
       |  <form action="confirmLtiAdvantage" method="POST">
       |    <input type="hidden" name="reference" value="$tokenRef" />
       |    <button type="submit">Confirm</button>
       |  </form>
       |
       |
       |</html>
       |
       |""".stripMargin

  /** Handler for requests generated by registering the tool in the Moodle LTI Advantage box */
  def ltiAdvantageRegistration(ctx:RoutingContext):Unit = {
    
    val safeChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwqyx0123456789"
    def safeString(n:Int):String = {
      ((0 until n).map { _ => 
        safeChars(Random.nextInt(safeChars.length))
      }).mkString
    }
    
    val req = ctx.request()

    println("LTI advangage...")

    (for {
      openIdConfigurationUrl <- req.refParam("openid_configuration")
      registrationToken <- req.refParam("registration_token")

      providerDetails <- getProviderOpenIdDetails(openIdConfigurationUrl)
    } yield {
      // Remember the details of this platform
      val tokenRef = safeString(16)
      platformTokens.put(tokenRef, PlatformDetails(registrationToken, providerDetails))
      
      // Show the confirmation dialog
      req.response().putHeader("Content-Type", "text/html")
      req.response().end(ltiAdvantageConfirmationText(tokenRef))
    }).recoverWith { case ex =>
      println(s"Failed ${ex.getMessage()}")
      RefOptFailed(ex)
    }
    //
  }

  def ltiAdvantageConfirmation(ctx:RoutingContext):Unit = {
    val req = ctx.request()
    
    for {
      tokenRef <- req.refParam("reference")
      details <- platformTokens.get(tokenRef).toRef
    } yield {
      val 
      println(s"Ready to make request to ")
      
      /*
         We must include:
           client_name
           initiate_login_url
           redirect_uris
           jwks_uri
           scope
       */
      
      ()
    }
    
  }
  

}
