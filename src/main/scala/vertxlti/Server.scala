package vertxlti

import io.vertx.core.http.{HttpHeaders, HttpMethod, HttpServerRequest}
import io.vertx.core.Vertx
import io.vertx.ext.web.{Router, RoutingContext}
import io.vertx.ext.web.handler.BodyHandler
import com.wbillingsley.handy._
import com.wbillingsley.handy.refOps

import scala.concurrent.{ExecutionContext, Future, Promise}


class Server(using vertx:Vertx) {

  lazy val server = vertx.createHttpServer()
  lazy val router = Router.router(vertx)
  lazy val client = vertx.createHttpClient()

  extension (req:HttpServerRequest) {
    def refParam(name:String):RefOpt[String] =
      Option.apply(req.getParam(name)).toRefOpt
  }
  
  extension[T] (vertxFut:io.vertx.core.Future[T])(using ec:ExecutionContext) {
    
    def toScala:Future[T] = {
      val p = Promise[T]
      vertxFut.onSuccess { x => p.success(x) }
      vertxFut.onFailure { x => p.failure(x) }
      p.future
    }
    
    def toRef:RefFuture[T] = {
      toScala.toRef(using ec)
    }
    
  }
  
  def getProviderOpenIdDetails(configUrl:String):Ref[PlatformOpenIdConfigRegElements] = {
    given ec:ExecutionContext = ExecutionContext.global
    
    for 
      req <- client.request(HttpMethod.GET, configUrl).toRef
      resp <- req.send().toRef
      json <- resp.body().toRef.map(_.toJsonObject())
    yield {
      PlatformOpenIdConfigRegElements(
        issuer = json.getString("issuer"),
        tokenEndPoint = json.getString("token_endpoint"),
        tokenEndPointAuthMethodsSupported = Seq.empty
      )
    }

  }
  
  def ltiAdvantageConfirmation(token:String):String =
    s"""<html>
       |
       |  <h1>Initiate tool registration via LTI Advantage</h1>
       |  
       |  <p>
       |  A registration authorisation token (valid for one hour) has been received from your LMS.
       |  </p>
       |  
       |  <p>
       |  Clicking "Confirm" will cause this tool to send a registration request to your
       |  LMS, to configure LTI 1.3 integration. This gives your LMS the URLs it needs in order
       |  to launch activities in this tool.
       |  </p>
       |  
       |  <p>
       |  If Moodle is your LMS, the tool integration will be in a "pending" state, awaiting
       |  a Moodle administrator to set it to active.
       |  </p>
       |  
       |  <p>
       |  If you do not wish to configure the tool in your LMS, simply close this dialog.
       |  The LMS's authorisation token will expire in one hour.
       |  </p>
       |  
       |  <form action="confirmLtiAdvantage" method="POST">
       |    <button type="submit">Confirm</button>
       |  </form>
       |
       |
       |</html>
       |
       |""".stripMargin
  
  /** Handler for requests generated by registering the tool in the Moodle LTI Advantage box */
  def ltiAdvantageRegistration(ctx:RoutingContext):Unit = {
    val req = ctx.request()
    
    println("LTI advangage...")
    
    (for 
      openIdConfigurationUrl <- req.refParam("openid_configuration")
      registrationToken <- req.refParam("registration_token")
      
      providerDetails <- getProviderOpenIdDetails(openIdConfigurationUrl)
    yield {
      println(s"Received $providerDetails")
      req.response().putHeader("Content-Type", "text/html")
      req.response().end(ltiAdvantageConfirmation(registrationToken))
    }).recoverWith { case ex => 
      println(s"Failed ${ex.getMessage()}")
      RefOptFailed(ex)
    }
      //
  }
  
  /** Handler for LTI 1.3 logi requests via POST */
  def login(ctx:RoutingContext):Unit = {
    val req = ctx.request()
    
    for 
      iss <- req.refParam("iss") orFail BadRequest("No issuer")
      loginHint <- req.refParam("login_hint").option
      targetLinkUri <- req.refParam("target_link_uri").option
      
      ltiMessageHint <- req.refParam("lti_message_hint").option
      ltiDeploymentId <- req.refParam("lti_deployment_id").option
      clientId <- req.refParam("client_id").option
    do {
      val msg = Lti13Login(
        iss=iss, loginHint=loginHint, targetLinkUri=targetLinkUri,
        ltiMessageHint=ltiMessageHint, ltiDeploymentId=ltiDeploymentId, clientId=clientId
      )
      
      // asas
      ctx.response().end(s"Login received: $msg")
    }

  }
  
  def start():Future[Unit] = {
    val p = Promise[Unit]
    
    router.route().handler(BodyHandler.create())
    
    router.get("/ping").handler((ctx) => ctx.request().response().end("Pong"))    
    router.post("/lti1.3/login").handler((ctx) => login(ctx))
    router.get("/lti1.3/advantageRegistration").handler((ctx) => ltiAdvantageRegistration(ctx))
    
    router.route().handler({ ctx =>
      
      println(s"Request... ${ctx.request().method().name()} ${ctx.request().path()}")
      
      val resp = ctx.response()
      resp.putHeader("Content-type", "text/plain")
      resp.end("Ping")
    })
      
    server.requestHandler(router).listen(8080, { http =>
      if (http.succeeded()) then
        println("Server started on 8080")
        p.success(())
      else
        println("Server failed to start")
        p.failure(http.cause())
    })
    
    p.future
  }

}
